<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      GCD | 程序羊的小巫 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="吴洋">
    
    

    <meta name="description" content="谈到iOS多线程，一般都会谈到四种方式：pthread、NSThread、GCD和NSOperation。其中，苹果推荐也是我们最经常使用的无疑是GCD。对于身为开发者的我们来说，并发一直都很棘手，如果对GCD的理解不够透彻，那么iOS开发的历程绝对不会顺利。这里，我会从几个角度浅谈我对GCD的理解。
一、多线程背景
Although threads have been around for ma">
<meta property="og:type" content="article">
<meta property="og:title" content="GCD | 程序羊的小巫">
<meta property="og:url" content="http://yoursite.com/2016/06/16/GCD/index.html">
<meta property="og:site_name" content="程序羊的小巫">
<meta property="og:description" content="谈到iOS多线程，一般都会谈到四种方式：pthread、NSThread、GCD和NSOperation。其中，苹果推荐也是我们最经常使用的无疑是GCD。对于身为开发者的我们来说，并发一直都很棘手，如果对GCD的理解不够透彻，那么iOS开发的历程绝对不会顺利。这里，我会从几个角度浅谈我对GCD的理解。
一、多线程背景
Although threads have been around for ma">
<meta property="og:updated_time" content="2016-06-16T10:53:32.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="GCD | 程序羊的小巫">
<meta name="twitter:description" content="谈到iOS多线程，一般都会谈到四种方式：pthread、NSThread、GCD和NSOperation。其中，苹果推荐也是我们最经常使用的无疑是GCD。对于身为开发者的我们来说，并发一直都很棘手，如果对GCD的理解不够透彻，那么iOS开发的历程绝对不会顺利。这里，我会从几个角度浅谈我对GCD的理解。
一、多线程背景
Although threads have been around for ma">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css" type="text/css">
    <link rel="stylesheet" href="/css/highlight.css" type="text/css">
    <link rel="stylesheet" href="/css/archive.css" type="text/css">
    <link rel="stylesheet" href="/css/china-social-icon.css" type="text/css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">程序羊的小巫</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">GCD</h1>

    

    <div class="post-meta">
      <time datetime="2016-06-16" class="post-meta__date date">2016-06-16</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <hr>
<p>谈到iOS多线程，一般都会谈到四种方式：pthread、NSThread、GCD和NSOperation。其中，苹果推荐也是我们最经常使用的无疑是GCD。对于身为开发者的我们来说，并发一直都很棘手，如果对GCD的理解不够透彻，那么iOS开发的历程绝对不会顺利。这里，我会从几个角度浅谈我对GCD的理解。</p>
<h2 id="u4E00_u3001_u591A_u7EBF_u7A0B_u80CC_u666F"><a href="#u4E00_u3001_u591A_u7EBF_u7A0B_u80CC_u666F" class="headerlink" title="一、多线程背景"></a>一、多线程背景</h2><blockquote>
<p>Although threads have been around for many years and continue to have their uses, they do not solve the general problem of executing multiple tasks in a scalable way. With threads, the burden of creating a scalable solution rests squarely on the shoulders of you, the developer. You have to decide how many threads to create and adjust that number dynamically as system conditions change. Another problem is that your application assumes most of the costs associated with creating and maintaining any threads it uses.</p>
</blockquote>
<p>上述大致说出了直接操纵线程实现多线程的弊端：</p>
<ul>
<li>开发人员必须根据系统的变化动态调整线程的数量和状态，即对开发者的负担重。</li>
<li>应用程序会在创建和维护线程上消耗很多成本，即效率低。</li>
</ul>
<p>相对的，GCD是一套低层级的C API，通过 GCD，开发者只需要向队列中添加一段代码块(block或C函数指针)，而不需要直接和线程打交道。GCD在后端管理着一个线程池，它不仅决定着你的代码块将在哪个线程被执行，还根据可用的系统资源对这些线程进行管理。GCD的工作方式，使其拥有很多优点（快、稳、准）：</p>
<ul>
<li>快，更快的内存效率，因为线程栈不暂存于应用内存。</li>
<li>稳，提供了自动的和全面的线程池管理机制，稳定而便捷。</li>
<li>准，提供了直接并且简单的调用接口，使用方便，准确。</li>
</ul>
<h2 id="u4E8C_u3001_u961F_u5217_u548C_u4EFB_u52A1"><a href="#u4E8C_u3001_u961F_u5217_u548C_u4EFB_u52A1" class="headerlink" title="二、队列和任务"></a>二、队列和任务</h2><p>初学GCD的时候，肯定会纠结一些看似很关键但却毫无意义的问题。比如：GCD和线程到底什么关系；异步任务到底在哪个线程工作；队列到底是个什么东西；mian queue和main thread到底搞什么名堂等等。现在，这些我们直接略过（最后拾遗中会谈一下），苹果既然推荐使用GCD，那么为什么还要纠结于线程呢？需要关注的只有两个概念：队列、任务。</p>
<h4 id="1-__u961F_u5217"><a href="#1-__u961F_u5217" class="headerlink" title="1. 队列"></a>1. 队列</h4><p>调度队列是一个对象，它会以first-in、first-out的方式管理您提交的任务。GCD有三种队列类型：</p>
<ul>
<li>串行队列，串行队列将任务以先进先出(FIFO)的顺序来执行，所以串行队列经常用来做访问某些特定资源的同步处理。你可以也根据需要创建多个队列，而这些队列相对其他队列都是并发执行的。换句话说，如果你创建了4个串行队列，每一个队列在同一时间都只执行一个任务，对这四个任务来说，他们是相互独立且并发执行的。如果需要创建串行队列，一般用dispatch_queue_create这个方法来实现，并指定队列类型DISPATCH_QUEUE_SERIAL。</li>
<li>并行队列，并发队列虽然是能同时执行多个任务，但这些任务仍然是按照先到先执行(FIFO)的顺序来执行的。并发队列会基于系统负载来合适地选择并发执行这些任务。并发队列一般指的就是全局队列(Global queue)，进程中存在四个全局队列：高、中(默认)、低、后台四个优先级队列，可以调用dispatch_get_global_queue函数传入优先级来访问队列。当然我们也可以用dispatch_queue_create，并指定队列类型DISPATCH_QUEUE_CONCURRENT，来自己创建一个并发队列。</li>
<li>主队列，与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个串行队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。<br>额外说一句，上面也说过，队列间的执行是并行的，但是也存在一些限制。比如，并行执行的队列数量受到内核数的限制，无法真正做到大量队列并行执行；比如，对于并行队列中的全局队列而言，其存在优先级关系，执行的时候也会遵循其优先顺序，而不是并行。</li>
</ul>
<h4 id="2-__u4EFB_u52A1"><a href="#2-__u4EFB_u52A1" class="headerlink" title="2. 任务"></a>2. 任务</h4><p>linux内核中的任务的定义是描述进程的一种结构体，而GCD中的任务只是一个代码块，它可以指在一个block或者函数指针。根据这个代码块添加进入队列的方式，将任务分为同步任务和异步任务：</p>
<ul>
<li>同步任务，使用dispatch_sync将任务加入队列。将同步任务加入串行队列，会顺序执行，一般不这样做并且在一个任务未结束时调起其它同步任务会死锁。将同步任务加入并行队列，会顺序执行，但是也没什么意义。</li>
<li>异步任务，使用dispatch_async将任务加入队列。将异步任务加入串行队列，会顺序执行，并且不会出现死锁问题。将异步任务加入并行队列，会并行执行多个任务，这也是我们最常用的一种方式。</li>
</ul>
<h4 id="3-__u7B80_u5355_u5E94_u7528"><a href="#3-__u7B80_u5355_u5E94_u7528" class="headerlink" title="3. 简单应用"></a>3. 简单应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#38431;&#21015;&#30340;&#21019;&#24314;&#65292;queue1:&#20013;&#65288;&#40664;&#35748;&#65289;&#20248;&#20808;&#32423;&#30340;&#20840;&#23616;&#24182;&#34892;&#38431;&#21015;&#12289;queue2:&#20027;&#38431;&#21015;&#12289;queue3:&#26410;&#25351;&#23450;type&#21017;&#20026;&#20018;&#34892;&#38431;&#21015;&#12289;queue4:&#25351;&#23450;&#20018;&#34892;&#38431;&#21015;&#12289;queue5:&#21046;&#23450;&#24182;&#34892;&#38431;&#21015;&#10;dispatch_queue_t queue1 = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&#10;dispatch_queue_t queue2 = dispatch_get_main_queue();&#10;dispatch_queue_t queue3 = dispatch_queue_create(&#34;queue3&#34;, NULL);&#10;dispatch_queue_t queue4 = dispatch_queue_create(&#34;queue4&#34;, DISPATCH_QUEUE_SERIAL);&#10;dispatch_queue_t queue5 = dispatch_queue_create(&#34;queue5&#34;, DISPATCH_QUEUE_CONCURRENT);&#10;&#10;// &#38431;&#21015;&#20013;&#28155;&#21152;&#24322;&#27493;&#20219;&#21153;&#10;dispatch_async(queue1, ^&#123;&#10;// &#20219;&#21153;&#10;...&#10;&#125;);&#10;&#10;&#10;// &#38431;&#21015;&#20013;&#28155;&#21152;&#21516;&#27493;&#20219;&#21153;&#10;dispatch_sync(queue1, ^&#123;&#10;// &#20219;&#21153;&#10;...&#10;&#125;);</span><br></pre></td></tr></table></figure>

  </section>

  
  
</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
